# Módulo Padrões de Projeto GoF(s) Comportamentais

## 1. Introdução

Os Padrões Comportamentais do _Gang of Four_ (GoF) representam um conjunto de soluções testadas e refinadas para modelar a interação e a colaboração entre objetos em sistemas de software. Segundo Gamma _et al._, esses padrões fornecem aos desenvolvedores ferramentas para criar designs flexíveis, escaláveis e de fácil manutenabilidade.

Ainda conforme os autores:

> "Os padrões comportamentais lidam com as responsabilidades e interações entre os objetos. Eles definem como os objetos comunicam, coordenam suas ações e distribuem tarefas. Esses padrões aumentam a flexibilidade do seu software, permitindo que você altere a forma como os objetos interagem sem alterar suas classes.” (GAMMA et al., 1994, p. 221)

Os padrões comportamentais do GoF se dividem em três categorias principais:

- Padrões de comunicação
  - Observador (Observer)
  - Mediador (Mediator)
- Padrões de comportamento
  - Estratégia (Strategy)
  - Método Modelo (Template Method)
- Padrões de responsabilidade
  - Cadeia de Responsabilidade (Chain of Responsability)
  - Comando (Command)
  - Estado (State)
  - Visitante (Visitor)
  - Interpretador (Interpreter)
  - Memento (Memento)

Será abordado neste artefato os seguintes GoFs comportamentais: Observador, Estratégia e Comando.

## 2. Metodologia

A priori foi elaborada uma divisão da equipe para que todos consigam discutir, elaborar, desenvolver e revisar diferentes partes do documento. A partir disso, foram dividos quatro principais responsáveis por levar à frente da modelagem e implementação do(s) GoF(s). A seguir, são definidos os **Revisores Principais** (responsáveis por revisar a respectiva modelagem e cobrar a elaboração do GoF à equipe responsável) e **Revisores Secundários** (responsáveis por revisar a implementação e demais pendências, como alterações no template da documentação).

|                             Nome                             |             Contribuição              |
| :----------------------------------------------------------: | :-----------------------------------: |
|   [Eduardo Rodrigues](https://github.com/Eduardo-RFarias)    | Desenvolvimento do GoF Comportamental |
| [Edilberto Cantuaria](https://github.com/edilbertocantuaria) | Desenvolvimento do GoF Comportamental |
|     [Matheus Silverio](https://github.com/MattSilverio)      | Desenvolvimento do GoF Comportamental |
|        [Artur Seppa](https://github.com/artur-seppa)         | Desenvolvimento do GoF Comportamental |
|        [Ana Letícia](https://github.com/analeticiaa)         |           Revisor Principal           |
|       [Suzane Duarte](https://github.com/suzaneduarte)       |           Revisor Principal           |
|    [João Pedro Anacleto](https://github.com/jpanacleto2)     |           Revisor Principal           |
|        [Cleber Brant](https://github.com/CleberBrant)        |           Revisor Principal           |
|       [Pablo Guilherme](https://github.com/PabloGJBS)        |          Revisor Secundário           |
|       [Luana Torres](https://github.com/luanatorress)        |          Revisor Secundário           |
|        [Wesley Lira](https://github.com/Weslin-0101)         |          Revisor Secundário           |
|         [Augusto Duarte](https://github.com/Augcamp)         |          Revisor Secundário           |

## 3. Padrão de Projeto Comportamental - Padrão Observador (Observer)

### 3.1. Base

Este padrão de GoF comportamental estabelece uma relação entre um objeto observado e vários objetos observadores, permitindo que estes sejam notificados sobre mudanças no estado do primeiro (Gamma et al., 1995).

No contexto da aplicação UnBreja, o padrão Observador funciona da seguinte forma:

- Usuário (Observado): Cada usuário é um objeto que pode ser observado. Ele mantém uma lista de outros usuários que estão interessados em suas atualizações.
- Combinações (Observadores): As combinações de um usuário são os observadores. Eles se registram para receber notificações sobre mudanças no perfil do usuário que eles estão acompanhando.
- Notificação: Quando um usuário altera seu perfil, ele notifica seus observadores. Cada combinação ("match") recebe essa notificação e pode atualizar sua interface para refletir as novas informações.

### 3.2. Modelagem

<center> 1. GoF comportamental Observador </center>
<br>

<div align = "center"><img src="https://raw.githubusercontent.com/UnBArqDsw2024-1/2024.1_G8_UnBreja/gh-pages/docs/assets/gof-comportamental/GOF_comportamental-Observador.png" alt="Figura 1: GoF comportamental Observador.">
</div>
<p align='center'>Figura 1: GoF comportamental Observador. Fonte: Artur Sepa, Edilberto Cantuaria 2024.</p>

### 3.3. Implementação

```java
public interface Observador {
	void atualizar();
}

```

```java
public class Combinacao implements Observador {

	@Override
	public void atualizar() {
		System.out.println("Combinação notificada!");
	}
}
```

```java	
import java.util.LinkedList;
import java.util.List;

public class Usuario {
	private final List<Observador> observadores = new LinkedList<>();

	public void adicionarObservador(Observador... observadores) {
		this.observadores.addAll(List.of(observadores));
	}

	public void removerObservador(Observador... observadores) {
		this.observadores.removeAll(List.of(observadores));
	}

	public void notificarObservador() {
		this.observadores.forEach(Observador::atualizar);
	}
}

```

```java
class Main {
	public static void main(String[] args) {
		var usuario = new Usuario();

		var combinacoes = new Combinacao[]{
				new Combinacao(),
				new Combinacao(),
				new Combinacao(),
				new Combinacao(),
				new Combinacao()
		};

		// Adiciona observadores
		usuario.adicionarObservador(combinacoes);

		// Notifica todos os observadores (5 registros de tela "Combinação notificada!")
		usuario.notificarObservador();

		// Remove um observador
		usuario.removerObservador(combinacoes[0]);

		// Notifica todos os observadores (4 registros de tela "Combinação notificada!")
		usuario.notificarObservador();
	}
}    
```

## 4. Padrão de Projeto Comportamental - Padrão Estratégia (Strategy)

### 4.1. Base

O padrão de GoF comportamental Estratégia (Strategy) encapsula um algoritmo em uma classe separada, possibilitando a troca de comportamentos sem alterar a estrutura das classes clientes (Gamma et al., 1995). O padrão de projeto Strategy é um padrão comportamental que permite que um sistema escolha o algoritmo a ser executado em tempo de execução. Ele faz isso definindo uma família de algoritmos, encapsulando cada um deles em uma classe distinta e tornando-os intercambiáveis. Essa abordagem facilita a alteração ou substituição de algoritmos de maneira flexível e dinâmica, sem modificar o código que os utiliza.

No contexto da aplicação UnBreja, o padrão Estratégia funciona da seguinte forma:

- Contexto: A tela principal onde os perfis são apresentados.
- Estratégias:
  - Aleatório: Organiza os perfis de forma aleatória.
  - Por Distância: Organiza os perfis pela distância em relação ao usuário.

### 4.2. Modelagem

<center> 2. GoF comportamental Estratégia </center>
<br>

<div align = "center"><img src="https://raw.githubusercontent.com/UnBArqDsw2024-1/2024.1_G8_UnBreja/gh-pages/docs/assets/gof-comportamental/GOF_comportamental_Estrategia.png" alt="Figura 2: GoF comportamental Estratégia.">
</div>
<p align='center'>Figura 2: GoF comportamental estratégia. Fonte: Artur Sepa, Eduardo Farias 2024.</p>

### 4.3. Implementação

Implementação com uso do Optional para tratar valores nulos.

```java
import java.util.Optional;

interface ICombinacao {
    void avaliarCombinacao(Usuario usuario);
}

class Usuario {
    private String nome;

    public Usuario(String nome) {
        this.nome = nome;
    }

    public String getNome() {
        return nome;
    }
}

class NamoroEstrategia implements ICombinacao {
    @Override
    public void avaliarCombinacao(Usuario usuario) {
        System.out.println("Avaliando match para namoro com o usuário: " + usuario.getNome());
    }
}

class AmizadeEstrategia implements ICombinacao {
    @Override
    public void avaliarCombinacao(Usuario usuario) {
        System.out.println("Avaliando match para amizade com o usuário: " + usuario.getNome());
    }
}

class RelacionamentoContexto {
    private Optional<ICombinacao> estrategia;

    public void setEstrategia(Optional<ICombinacao> estrategia) {
        this.estrategia = estrategia;
    }

    public void avaliarCombinacao(Usuario usuario) {
        if (estrategia.isPresent()) {
            estrategia.get().avaliarCombinacao(usuario);
        } else {
            System.out.println("Nenhuma estratégia definida para avaliar combinações.");
        }
    }
}

// Classe principal para demonstrar o uso do Padrão Strategy
public class Main {
    public static void main(String[] args) {
        Usuario usuario = new Usuario("MattSilverio");

        RelacionamentoContexto relacionamento = new RelacionamentoContexto();

        // Definindo a estratégia como Namoro
        relacionamento.setEstrategia(Optional.of(new NamoroEstrategia()));
        relacionamento.avaliarCombinacao(usuario);

        // Mudando a estratégia para Amizade
        relacionamento.setEstrategia(Optional.of(new AmizadeEstrategia()));
        relacionamento.avaliarCombinacao(usuario);

        // Sem estratégia
        relacionamento.setEstrategia(Optional.empty());
        relacionamento.avaliarCombinacao(usuario);
    }
}
```

## 5. Padrão de Projeto Comportamental - Padrão Comando (Command)

### 5.1. Base

Este padrão de GoF comportamental Comando (Command) encapsula uma solicitação como um objeto, permitindo que você enfileire, registre e execute solicitações de maneira independente. Imagine um sistema de edição de texto que armazena comandos como "inserir", "excluir" e "formatar" para desfazer ou refazer ações. (Gamma et al., 1995)

No contexto da aplicação UnBreja, o padrão Comando permite aos usuários curtir, não curtir ou enviar mensagens para outros usuários. Cada uma dessas ações pode ser considerada um comando. O padrão Command nos permite encapsular essas ações em objetos, permitindo que sejam armazenadas, desfeitas e reexecutadas.

**Em termos mais técnicos:**
O padrão Comando encapsula uma solicitação como um objeto, separando a invocação de uma operação do objeto que a executa. Isso permite que:

- Enfileire solicitações: Armazenar comandos para serem executados mais tarde.
- Desfazer e refazer: Reverter ou repetir ações.
- Logar solicitações: Registrar um histórico das ações realizadas.

No contexto do UnBreja:

- Comando: Cada ação do usuário (curtir, não curtir, enviar mensagem) é um comando.
- Invocador: O botão que o usuário clica para executar a ação.
- Receptor: O perfil do outro usuário que recebe a ação.

### 5.2. Modelagem

<center> 3. GoF comportamental Comando </center>
<br>

<div align = "center"><img src="https://raw.githubusercontent.com/UnBArqDsw2024-1/2024.1_G8_UnBreja/gh-pages/docs/assets/gof-comportamental/GOF_comportamental_Comando.png" alt="Figura 3: GoF comportamental Comando.">
</div>
<p align='center'>Figura 3: GoF comportamental comando. Fonte: Artur Sepa, Edilberto Cantuaria 2024.</p>

### 5.3. Implementação

```java
interface Comando {
    void executar();
}

// Comando para enviar mensagem
class EnviarMensagem implements Comando {
    private Receptor receptor;
    private String mensagem;

    public EnviarMensagem(Receptor receptor, String mensagem) {
        this.receptor = receptor;
        this.mensagem = mensagem;
    }

    @Override
    public void executar() {
        receptor.acao1(mensagem);
    }
}

// Comando para curtir
class Curtir implements Comando {
    private Receptor receptor;

    public Curtir(Receptor receptor) {
        this.receptor = receptor;
    }

    @Override
    public void executar() {
        receptor.acao2();
    }
}

// Comando para descurtir
class Descurtir implements Comando {
    private Receptor receptor;

    public Descurtir(Receptor receptor) {
        this.receptor = receptor;
    }

    @Override
    public void executar() {
        receptor.acao3();
    }
}

// Receptor que contém a lógica de execução das ações
class Receptor {
    private String nome;

    public Receptor(String nome) {
        this.nome = nome;
    }
    
    public String getNome(){
        return this.nome;
    }

    public void acao1(String mensagem) {
        System.out.println(nome + " recebeu a mensagem: " + mensagem);
    }

    public void acao2() {
        System.out.println(nome + " foi curtido.");
    }

    public void acao3() {
        System.out.println(nome + " foi descurtido.");
    }
}

// Invocador que armazena e executa comandos
class Invocador {
    private Comando comando;

    public void setComando(Comando comando) {
        this.comando = comando;
    }

    public void executarComando() {
        if (comando != null) {
            comando.executar();
        } else {
            System.out.println("Nenhum comando foi definido.");
        }
    }
}

public class Main {
    public static void main(String[] args) {
        Receptor receptor1 = new Receptor("João");
        Receptor receptor2 = new Receptor("Maria");

        Invocador invocador = new Invocador();

        // Criando comandos e executando
        Comando enviarMensagem = new EnviarMensagem(receptor1, "Olá, " + receptor1.getNome() +"!");
        invocador.setComando(enviarMensagem);
        invocador.executarComando();

        Comando curtir = new Curtir(receptor2);
        invocador.setComando(curtir);
        invocador.executarComando();

        Comando descurtir = new Descurtir(receptor2);
        invocador.setComando(descurtir);
        invocador.executarComando();
    }
}
```

## 6. Conclusão

Os padrões comportamentais do GoF abordados neste documento – Observador, Estratégia e Comando – revelaram-se, conforme dito na introdução,ferramentas poderosas para a criação de sistemas de software flexíveis e de fácil manutenção. Cada padrão oferece soluções específicas para problemas recorrentes, promovendo a separação de responsabilidades e a modularidade do código.

A Tabela 1 abaixo detalha alguns pontos fortes e fracos que cada padrão de comportamento adotado neste artefato.

| Padrão     | Pontos Fortes                                                                                                                                                                                                                                                                                                                             | Pontos Fracos                                                                                                                                                                                                                                                                                                          |
| ---------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Observador | - Facilita a implementação de sistemas de notificação, permitindo que múltiplos objetos sejam informados sobre mudanças de estado de um objeto observado. <br> - Promove um design desacoplado, onde os observadores são independentes do objeto observado, resultando em maior flexibilidade e reutilização do código.                   | - Pode introduzir complexidade adicional na gestão de notificações, especialmente em sistemas com muitos observadores, o que pode impactar a performance. <br> - A adição e remoção dinâmica de observadores pode ser propensa a erros, exigindo cuidado na implementação.                                             |
| Estratégia | - Permite a intercambialidade de algoritmos sem alterar o contexto onde são aplicados, promovendo a reutilização de código e a facilidade de manutenção. <br> - Encapsula comportamentos específicos em classes separadas, tornando o sistema extensível e permitindo a introdução de novas estratégias sem modificar o código existente. | - Pode aumentar a complexidade do código devido ao grande número de classes e objetos necessários para representar diferentes estratégias. <br> - A escolha da estratégia adequada pode requerer um conhecimento aprofundado do domínio do problema, o que pode ser desafiador para desenvolvedores menos experientes. |
| Comando    | - Encapsula solicitações como objetos, facilitando a implementação de funcionalidades como enfileiramento, log e desfazer/refazer ações. <br> - Separa a invocação de uma operação do objeto que a executa, promovendo a flexibilidade e a extensibilidade do sistema.                                                                    | - A implementação pode ser complexa, especialmente ao lidar com comandos compostos e o gerenciamento do histórico de ações. <br> - Pode resultar em uma proliferação de classes de comando, aumentando a complexidade do sistema.                                                                                      |

<center>
Tabela 01: Pontos fortes e fracos dos padrões de comportamento GoF adotados.<br/>
</center>
<br/>

A aplicação prática dos padrões comportamentais do GoF no desenvolvimento da aplicação UnBreja demonstra o poder desses padrões na solução de problemas comuns de design. Através do uso dos padrões Observador, Estratégia e Comando, cria-se um sistema mais modular, flexível e de fácil manutenabilidade. No entanto, é crucial que os desenvolvedores ponderem os benefícios e as desvantagens de cada padrão, considerando o contexto específico de sua aplicação.

## Colaboração e Trabalho em Equipe
A colaboração e o trabalho em equipe foram fundamentais para o sucesso do projeto de implementação dos Padrões de Projeto Comportamentais do GoF no contexto da aplicação UnBreja. A equipe, composta por desenvolvedores e revisores, discutiu abordagens e chegou a consensos importantes para a finalização do trabalho.

### Reuniões e Discussões
#### Primeira Reunião - Definição de Papéis e Responsabilidades
Na primeira reunião, em 19 de julho de 2024, definimos os papéis de cada membro, bem como os revisores. A reunião foi realizada de forma mais informal por trocas de mensagem via *Whatsapp*. 

#### Segunda Reunião - Escolha dos Padrões a Serem Implementados
Em 22 de julho de 2024, discutimos quais padrões comportamentais implementar. Após debate, escolhemos os padrões "Observador", "Estratégia" e "Comando". Novamente,a reunião foi realizada de forma mais informal por trocas de mensagem via *Whatsapp*. 

#### Desenvolvimento e Implementação
##### Padrão Observador
[Eduardo](https://github.com/Eduardo-RFarias) e [Edilberto](https://github.com/edilbertocantuaria) optaram por definição da interface de comunicação até conseguirem entender um pouco melhor o conceito. [Matheus Silvério](https://github.com/MattSilverio) sugeriu a abordagem baseada em eventos, que foi aceita após ajustes. [Ana Letícia](https://github.com/analeticiaa) e [Cleber Brant](https://github.com/CleberBrant) revisaram e melhoraram a clareza do código.

#####  Padrão Estratégia
[Matheus Silvério](https://github.com/MattSilverio) e [Eduardo](https://github.com/Eduardo-RFarias) propuseram diferentes estratégias de organização dos perfis. [Artur Seppa](https://github.com/artur-seppa) modelou o diagrama. Após discussões, a equipe optou por utilizar interfaces para cada estratégia. [Pablo Guilherme](https://github.com/PabloGJBS) e [Ana Letícia](https://github.com/analeticiaa) revisaram a implementação e documentação.

#####  Padrão Comando
Houve debate sobre encapsular ações de curtir, não curtir e enviar mensagens. [Suzane Duarte](https://github.com/suzaneduarte) propôs classes abstratas, enquanto [João Pedro Anacleto](https://github.com/jpanacleto2) sugeriu classes concretas. Optamos pela solução de [João Pedro Anacleto](https://github.com/jpanacleto2). [Luana Torres](https://github.com/luanatorress), [Wesley Lira](https://github.com/Weslin-0101) e [Augusto Duarte](https://github.com/Augcamp) ajudaram a corrigir bugs na lógica de execução dos comandos.

## Referências

> GAMMA, Erich; HELM, Richard; JOHNSON, Ralph; VLISSIDES, John. Design Patterns: Elements of Reusable Object-Oriented Software. Boston: Addison-Wesley, 1994. Disponível em: <https://www.javier8a.com/itc/bd1/articulo.pdf>. Acesso em: 24 jul. de 2024.

> **Página sobre GoF Strategy** [Site Refactoring Guru](https://refactoring.guru/pt-br/design-patterns/strategy). Acesso em 24 julho 2024.

> **Página sobre GoF Observer** [Site Refactoring Guru](https://refactoring.guru/pt-br/design-patterns/observer). Acesso em 25 julho 2024.

> **Página sobre GoF Command** [Site Refactoring Guru](https://refactoring.guru/pt-br/design-patterns/command). Acesso em 25 julho 2024.

## Controle de Versionamento

| Versão | Data da alteração |                                                                                  Alteração                                                                                   |                                            Responsável                                             |                        Revisor                        | Data de revisão |
| :----: | :---------------: | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------: | :------------------------------------------------------------------------------------------------: | :---------------------------------------------------: | :-------------: |
|  1.0   |    18/07/2024     |                                                                       Criação do template do artefato                                                                        |                          [Suzane Duarte](https://github.com/suzaneduarte)                          |    [Cleber Brant](https://github.com/CleberBrant)     |   24/07/2024    |
|  1.1   |    24/07/2024     |                                                                            Implementação do texto                                                                            |                    [Edilberto Cantuaria](https://github.com/edilbertocantuaria)                    | [João Pedro Anacleto](https://github.com/jpanacleto2) |   24/07/2024    |
|  1.2   |    24/07/2024     |                                                                       Implementação do Padrão Strategy                                                                       | [Matheus Silverio](https://github.com/MattSilverio), [Eduardo](https://github.com/Eduardo-RFarias) |    [Pablo Guilherme](https://github.com/PabloGJBS)    |   24/07/2024    |
|  1.3   |    24/07/2024     |                                                                         Diagrama do Padrão Strategy                                                                          |    [Artur Seppa](https://github.com/artur-seppa), [Eduardo](https://github.com/Eduardo-RFarias)    |     [Ana Letícia](https://github.com/analeticiaa)     |   24/07/2024    |
|  1.3   |    24/07/2024     | Revisão: Correção na linguagem do código para PTBR seguindo o padrão do restante do projeto e solicitação para mudança na modelagem para troca de linguagem também para PTBR |                          [Pablo Guilherme](https://github.com/PabloGJBS)                           | [João Pedro Anacleto](https://github.com/jpanacleto2) |   24/07/2024    |
|  1.4  |    25/07/2024     | Modelagem dos padrões restantes e Implementação do padrão Observer |       [Edilberto Cantuaria](https://github.com/edilbertocantuaria), [Eduardo](https://github.com/Eduardo-RFarias)                          | [João Pedro Anacleto](https://github.com/jpanacleto2) |   25/07/2024    |
|  1.5 |    25/07/2024     | Implementação do padrão Command |                   [Matheus Silverio](https://github.com/MattSilverio)                           | [João Pedro Anacleto](https://github.com/jpanacleto2) |   24/07/2024    |
