# Módulo Padrões de Projeto GoF(s) Comportamentais

## 1. Introdução

Os Padrões Comportamentais do _Gang of Four_ (GoF) representam um conjunto de soluções testadas e refinadas para modelar a interação e a colaboração entre objetos em sistemas de software. Segundo Gamma _et al._, esses padrões fornecem aos desenvolvedores ferramentas para criar designs flexíveis, escaláveis e de fácil manutenabilidade.

Ainda conforme os autores:

> "Os padrões comportamentais lidam com as responsabilidades e interações entre os objetos. Eles definem como os objetos comunicam, coordenam suas ações e distribuem tarefas. Esses padrões aumentam a flexibilidade do seu software, permitindo que você altere a forma como os objetos interagem sem alterar suas classes.” (GAMMA et al., 1994, p. 221)

Os padrões comportamentais do GoF se dividem em três categorias principais:

- Padrões de comunicação
  - Observador (Observer)
  - Mediador (Mediator)
- Padrões de comportamento
  - Estratégia (Strategy)
  - Método Modelo (Template Method)
- Padrões de responsabilidade
  - Cadeia de Responsabilidade (Chain of Responsability)
  - Comando (Command)
  - Estado (State)
  - Visitante (Visitor)
  - Interpretador (Interpreter)
  - Memento (Memento)

Será abordado neste artefato os seguintes GoFs comportamentais: Observador, Estratégia e Comando.

## 2. Metodologia

A priori foi elaborada uma divisão da equipe para que todos consigam discutir, elaborar, desenvolver e revisar diferentes partes do documento. A partir disso, foram dividos quatro principais responsáveis por levar à frente da modelagem e implementação do(s) GoF(s). A seguir, são definidos os **Revisores Principais** (responsáveis por revisar a respectiva modelagem e cobrar a elaboração do GoF à equipe responsável) e **Revisores Secundários** (responsáveis por revisar a implementação e demais pendências, como alterações no template da documentação).

|                             Nome                             |             Contribuição              |
| :----------------------------------------------------------: | :-----------------------------------: |
|   [Eduardo Rodrigues](https://github.com/Eduardo-RFarias)    | Desenvolvimento do GoF Comportamental |
| [Edilberto Cantuaria](https://github.com/edilbertocantuaria) | Desenvolvimento do GoF Comportamental |
|     [Matheus Silverio](https://github.com/MattSilverio)      | Desenvolvimento do GoF Comportamental |
|        [Artur Seppa](https://github.com/artur-seppa)         | Desenvolvimento do GoF Comportamental |
|        [Ana Letícia](https://github.com/analeticiaa)         |           Revisor Principal           |
|       [Suzane Duarte](https://github.com/suzaneduarte)       |           Revisor Principal           |
|    [João Pedro Anacleto](https://github.com/jpanacleto2)     |           Revisor Principal           |
|        [Cleber Brant](https://github.com/CleberBrant)        |           Revisor Principal           |
|       [Pablo Guilherme](https://github.com/PabloGJBS)        |          Revisor Secundário           |
|       [Luana Torres](https://github.com/luanatorress)        |          Revisor Secundário           |
|        [Wesley Lira](https://github.com/Weslin-0101)         |          Revisor Secundário           |
|         [Augusto Duarte](https://github.com/Augcamp)         |          Revisor Secundário           |

## 3. Padrão de Projeto Comportamental - Padrão Observador (Observer)

### 3.1. Base

Este padrão de GoF comportamental estabelece uma relação entre um objeto observado e vários objetos observadores, permitindo que estes sejam notificados sobre mudanças no estado do primeiro (Gamma et al., 1995).

No contexto da aplicação UnBreja, o padrão Observador funciona da seguinte forma:

- Usuário (Observado): Cada usuário é um objeto que pode ser observado. Ele mantém uma lista de outros usuários que estão interessados em suas atualizações.
- Combinações (Observadores): As combinações de um usuário são os observadores. Eles se registram para receber notificações sobre mudanças no perfil do usuário que eles estão acompanhando.
- Notificação: Quando um usuário altera seu perfil, ele notifica seus observadores. Cada combinação ("match") recebe essa notificação e pode atualizar sua interface para refletir as novas informações.

### 3.2. Modelagem

[GRÁFICO]

### 3.3. Implementação

[CÓDIGO]

## 4. Padrão de Projeto Comportamental - Padrão Estratégia (Strategy)

### 4.1. Base

O padrão de GoF comportamental Estratégia (Strategy) encapsula um algoritmo em uma classe separada, possibilitando a troca de comportamentos sem alterar a estrutura das classes clientes (Gamma et al., 1995). O padrão de projeto Strategy é um padrão comportamental que permite que um sistema escolha o algoritmo a ser executado em tempo de execução. Ele faz isso definindo uma família de algoritmos, encapsulando cada um deles em uma classe distinta e tornando-os intercambiáveis. Essa abordagem facilita a alteração ou substituição de algoritmos de maneira flexível e dinâmica, sem modificar o código que os utiliza.

No contexto da aplicação UnBreja, o padrão Estratégia funciona da seguinte forma:

- Contexto: A tela principal onde os perfis são apresentados.
- Estratégias:
  - Aleatório: Organiza os perfis de forma aleatória.
  - Por Distância: Organiza os perfis pela distância em relação ao usuário.

### 4.2. Modelagem

<center> 2. GoF comportamental Strategy </center>
<br>

<div align = "center"><img src="https://raw.githubusercontent.com/UnBArqDsw2024-1/2024.1_G8_UnBreja/gh-pages/docs/assets/gof-comportamental/GoFComportamentalStrategy.png" alt="Figura 1: GoF comportamental Strategy.">
</div>
<p align='center'>Figura 2: GoF comportamental Strategy. Fonte: Artur Sepa, Eduardo Farias 2024.</p>

### 4.3. Implementação

Implementação com uso do Optional para tratar valores nulos.

```java
import java.util.Optional;

interface ICombinacao {
    void avaliarCombinacao(Usuario usuario);
}

class Usuario {
    private String nome;

    public Usuario(String nome) {
        this.nome = nome;
    }

    public String getNome() {
        return nome;
    }
}

class NamoroEstrategia implements ICombinacao {
    @Override
    public void avaliarCombinacao(Usuario usuario) {
        System.out.println("Avaliando match para namoro com o usuário: " + usuario.getNome());
    }
}

class AmizadeEstrategia implements ICombinacao {
    @Override
    public void avaliarCombinacao(Usuario usuario) {
        System.out.println("Avaliando match para amizade com o usuário: " + usuario.getNome());
    }
}

class RelacionamentoContexto {
    private Optional<ICombinacao> estrategia;

    public void setEstrategia(Optional<ICombinacao> estrategia) {
        this.estrategia = estrategia;
    }

    public void avaliarCombinacao(Usuario usuario) {
        if (estrategia.isPresent()) {
            estrategia.get().avaliarCombinacao(usuario);
        } else {
            System.out.println("Nenhuma estratégia definida para avaliar combinações.");
        }
    }
}

// Classe principal para demonstrar o uso do Padrão Strategy
public class Main {
    public static void main(String[] args) {
        Usuario usuario = new Usuario("MattSilverio");

        RelacionamentoContexto relacionamento = new RelacionamentoContexto();

        // Definindo a estratégia como Namoro
        relacionamento.setEstrategia(Optional.of(new NamoroEstrategia()));
        relacionamento.avaliarCombinacao(usuario);

        // Mudando a estratégia para Amizade
        relacionamento.setEstrategia(Optional.of(new AmizadeEstrategia()));
        relacionamento.avaliarCombinacao(usuario);

        // Sem estratégia
        relacionamento.setEstrategia(Optional.empty());
        relacionamento.avaliarCombinacao(usuario);
    }
}
```

## 5. Padrão de Projeto Comportamental - Padrão Comando (Command)

### 5.1. Base

Este padrão de GoF comportamental Comando (Command) encapsula uma solicitação como um objeto, permitindo que você enfileire, registre e execute solicitações de maneira independente. Imagine um sistema de edição de texto que armazena comandos como "inserir", "excluir" e "formatar" para desfazer ou refazer ações. (Gamma et al., 1995)

No contexto da aplicação UnBreja, o padrão Comando permite aos usuários curtir, não curtir ou enviar mensagens para outros usuários. Cada uma dessas ações pode ser considerada um comando. O padrão Command nos permite encapsular essas ações em objetos, permitindo que sejam armazenadas, desfeitas e reexecutadas.

**Em termos mais técnicos:**
O padrão Comando encapsula uma solicitação como um objeto, separando a invocação de uma operação do objeto que a executa. Isso permite que:

- Enfileire solicitações: Armazenar comandos para serem executados mais tarde.
- Desfazer e refazer: Reverter ou repetir ações.
- Logar solicitações: Registrar um histórico das ações realizadas.

No contexto do UnBreja:

- Comando: Cada ação do usuário (curtir, não curtir, enviar mensagem) é um comando.
- Invocador: O botão que o usuário clica para executar a ação.
- Receptor: O perfil do outro usuário que recebe a ação.

### 5.2. Modelagem

[GRÁFICO]

### 5.3. Implementação

[CÓDIGO]

## 6. Conclusão

Os padrões comportamentais do GoF abordados neste documento – Observador, Estratégia e Comando – revelaram-se, conforme dito na introdução,ferramentas poderosas para a criação de sistemas de software flexíveis e de fácil manutenção. Cada padrão oferece soluções específicas para problemas recorrentes, promovendo a separação de responsabilidades e a modularidade do código.

A Tabela 1 abaixo detalha alguns pontos fortes e fracos que cada padrão de comportamento adotado neste artefato.

| Padrão     | Pontos Fortes                                                                                                                                                                                                                                                                                                                             | Pontos Fracos                                                                                                                                                                                                                                                                                                          |
| ---------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Observador | - Facilita a implementação de sistemas de notificação, permitindo que múltiplos objetos sejam informados sobre mudanças de estado de um objeto observado. <br> - Promove um design desacoplado, onde os observadores são independentes do objeto observado, resultando em maior flexibilidade e reutilização do código.                   | - Pode introduzir complexidade adicional na gestão de notificações, especialmente em sistemas com muitos observadores, o que pode impactar a performance. <br> - A adição e remoção dinâmica de observadores pode ser propensa a erros, exigindo cuidado na implementação.                                             |
| Estratégia | - Permite a intercambialidade de algoritmos sem alterar o contexto onde são aplicados, promovendo a reutilização de código e a facilidade de manutenção. <br> - Encapsula comportamentos específicos em classes separadas, tornando o sistema extensível e permitindo a introdução de novas estratégias sem modificar o código existente. | - Pode aumentar a complexidade do código devido ao grande número de classes e objetos necessários para representar diferentes estratégias. <br> - A escolha da estratégia adequada pode requerer um conhecimento aprofundado do domínio do problema, o que pode ser desafiador para desenvolvedores menos experientes. |
| Comando    | - Encapsula solicitações como objetos, facilitando a implementação de funcionalidades como enfileiramento, log e desfazer/refazer ações. <br> - Separa a invocação de uma operação do objeto que a executa, promovendo a flexibilidade e a extensibilidade do sistema.                                                                    | - A implementação pode ser complexa, especialmente ao lidar com comandos compostos e o gerenciamento do histórico de ações. <br> - Pode resultar em uma proliferação de classes de comando, aumentando a complexidade do sistema.                                                                                      |

<center>
Tabela 01: Pontos fortes e fracos dos padrões de comportamento GoF adotados.<br/>
</center>
<br/>

A aplicação prática dos padrões comportamentais do GoF no desenvolvimento da aplicação UnBreja demonstra o poder desses padrões na solução de problemas comuns de design. Através do uso dos padrões Observador, Estratégia e Comando, cria-se um sistema mais modular, flexível e de fácil manutenabilidade. No entanto, é crucial que os desenvolvedores ponderem os benefícios e as desvantagens de cada padrão, considerando o contexto específico de sua aplicação.

## Colaboração e Trabalho em Equipe

## Referências

> GAMMA, Erich; HELM, Richard; JOHNSON, Ralph; VLISSIDES, John. Design Patterns: Elements of Reusable Object-Oriented Software. Boston: Addison-Wesley, 1994. Disponível em: <https://www.javier8a.com/itc/bd1/articulo.pdf>. Acesso em: 24 jul. de 2024.

> **Pagina sobre GoF Strategy** [Site Refactoring Guru](https://refactoring.guru/pt-br/design-patterns/strategy). Acesso em 24 julho 2024.

## Controle de Versionamento


